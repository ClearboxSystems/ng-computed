* ng-computed

Computed properties for [[http://angularjs.org/][AngularJS]], Ã  la [[http://knockoutjs.com/][Knockout JS]].

: bower install ng-computed


** Motivation

When writing applications within the AngularJS framework, it is often
necessary to compute values for scope properties which are dependent
on other scope values. AngularJS provides a basic mechanism to keep
these values up to date (=$watch=, and its variants), but these can
often become unwieldy as your dependencies become more complex or
dynamic.

This is the problem that ~ng-computed~ is aiming to solve. Within a
=$computed= value's body it is not necessary to explicitly declare
what values you depend on, or when this value should be
re-evaluated. ~ng-computed~ will take care of all the details so you
can focus on your actual computation.

If you're not convinced that this is such a great idea, take a look at
[[Hello%20World%20Example][the example below]]. If you're interested in how everything works, jump
down to [[Internals][our description of the internals]]. If you're just interested in
using ~ng-computed~ then [[Installation][installation is probably the best place to
start]].


** Hello World Example

#+BEGIN_SRC js
  angular.module('app', ['ngComputed', 'ng'])
      .controller('HelloWorldController', function($scope, $computed, $trackedEval) {
          angular.extend($scope, {$computed: $computed, $eval: $trackedEval});
          $scope.hello = "hello";
          $scope.world = "world";
          $scope.$computed("helloWorld", function() {
              return $scope.$eval("hello") + " " + $scope.$eval("world") + "!";
          });
      });
#+END_SRC

=$scope.helloWorld= will be kept updated by the usual AngularJS watch
mechanisms, and it will be recalculated whenever the values of
=$scope.hello= or =$scope.world= change.

For a more complete example, see [[Comparison to pure AngularJS][the comparative example below]].


** Installation

There are a few options for how to set up ~ng-computed~ in your
project.

*** Globally available

We can add the =$computed= and =$trackedEval= methods at the
top-level of our application, on the =Scope= prototype. This makes
them readily available to any scopes, including isolate scopes. When
placing values on the =Scope= prototype we have another decision to
make: do we want to replace =Scope.$eval=.

**** Overriding =Scope.$eval=

The =$trackedEval= service gives you a drop-in replacement for
=Scope.$eval=, so we can replace =Scope.$eval= with =$trackedEval=
without breaking anything.

#+BEGIN_SRC js
  angular.module('app', ['ngComputed', 'ng'])
      .run(function($rootScope, $trackedEval, $computed) {
          // we have to use the prototype, otherwise isolate scopes miss out
          angular.extend($rootScope.constructor.prototype, {
              $eval: $trackedEval,
              $computed: $computed
          });
      });
#+END_SRC

**** Not overriding =Scope.$eval=

If you don't want to override =Scope.$eval= then you can choose a
different name instead. ~ng-computed~ makes no assumptions about what
names you use in your application.

#+BEGIN_SRC js
  angular.module('app', ['ngComputed', 'ng'])
      .run(function($rootScope, $trackedEval, $computed) {
          // we have to use the prototype, otherwise isolate scopes miss out
          angular.extend($rootScope.constructor.prototype, {
              getExpressionValue: $trackedEval,
              computedProperty: $computed
          });
      });
#+END_SRC

*** Locally available

If you don't want to add =$computed= or =$trackedEval= to the =Scope=
prototype then you can still use ~ng-computed~. Within any scope you
can add =$computed= and =$trackedEval=, using any names you desire,
and they will function normally.

#+BEGIN_SRC js
  angular.module('app', ['ngComputed', 'ng'])
      .controller('ExampleController', function($scope, $trackedEval, $computed) {
          $scope.$eval = $trackedEval;
          $scope.$computed = $computed;
      });
#+END_SRC


** Custom behaviour

*** Watches

By default, =$trackedEval= tracks all dependencies as *deep equality*
watches. This can be quite inefficient, especially for dependencies
on large objects, so ~ng-computed~ provides two tools to help:

1. =$watch= binding

   Shipped along with ~ng-computed~ is a service called
   =$batchedWatch= which is a drop-in replacement for =Scope.$watch=.
   =$batchedWatch= can be used as =$watch= on the =Scope= prototype,
   or on any individual scope, and will batch together separate watch
   functions on the same expression. This means that multiple deep
   watches on the same large object will incur only one =angular.copy=
   / =angular.equals= per change.

   #+BEGIN_SRC js
     angular.module('app', ['ngComputed', 'ng'])
         .run(function($rootScope, $batchedWatch) {
             $rootScope.constructor.prototype.$watch = $batchedWatch;
         });
   #+END_SRC

2. =$eval{Reference,Equal,Collection}=

   The =$trackedEval= service is not just a simple function. There
   are three variations of =$trackedEval= which each track the
   dependency as one of the varieties of watch:

   * =$evalReference=, as a reference watch
   * =$evalEqual=, as a deep equality watch
   * =$evalCollection=, as a collection watch

   These can be placed on a scope and used as normal:

   #+BEGIN_SRC js
     angular.module('app', ['ngComputed', 'ng'])
         .controller('Example', function($scope, $trackedEval) {
             $scope.$evalReference = $trackedEval.$evalReference;
             $scope.$computed('computedValue', function() {
                 return $scope.$evalReference('shallowWatchedValue');
             });
         });
   #+END_SRC

   By default, =$trackedEval= is the =$evalEqual= function, but it
   can be configured using AngularJS's configuration mechanism:

   #+BEGIN_SRC js
     angular.module('app', ['ngComputed', 'ng'])
         .config(['$trackedEvalProvider', function($trackedEvalProvider) {
             $trackedEvalProvider.setDefaultWatchType('equal' /* or 'reference' or 'collection'*/);
         }]);
   #+END_SRC


*** Extractors

Often when a value is returned for a =$computed= property there is
some more work to be done: the value needs to be /extracted/ from some
sort of context. This may be from a asynchronous construct, such as a
promise, or from some other wrapper structure of your own devising. In
order to allow for easy use of such values, ~ng-computed~ has a
concept of an /extractor/.

An extractor is a function which is called to retrieve a value from a
container. The function is given the value returned to =$computed= and
a callback into which to deliver the value. The callback may be called
as many times as desired, and each time it is called it will continue
the evaluation of the =$computed= value (this may be simply setting it
on the scope, or may result in further computation [see
[[Transformations]] for more details]).


**** Asynchronous extractors

Asynchronous extractors have a few behaviours which may be unexpected,
and may have unintended consequences. These should be taken into
account when writing extractors for asynchronous results.

1. It is the extractor's responsibility to ensure that *any changes
   are =$digest=\ed after extraction*. The extractor may assume that
   it will have been invoked during the =$apply= or =$digest= phase.

   Essentially this means that whenever you are invoking =callback=
   asynchronously you must ensure that it is run within a
   =$rootScope.$apply=, or similar:

   #+BEGIN_SRC js
     $rootScope.$apply(function() {
         callback(value);
     });
   #+END_SRC

   This is usually not a problem when using AngularJS services (such
   as =$q= or =$timeout=), but when using third-party promises or
   other callback mechanisms it can become an issue.

2. The =callback= provided to extractors is only valid until the
   function calculating =value= is invoked again. If the =callback=
   is invoked after that time then it will have no effect.

   The intention behind this decision is to avoid the case where an
   earlier, but now irrelevant, promise being resolved overwrites a
   newer, relevant, promise's value. An example will hopefully make
   this clear:

   #+BEGIN_SRC js
     var deferredA = $q.defer(), deferredB = $q.defer();
     
     $scope.$apply(function() {
         $scope.useA = true;
         $scope.$computed('extractedValue', function() {
             if ($scope.$eval('useA'))
                 return deferredA.promise;
             else
                 return deferredB.promise;
         });
     });
     
     // we're now waiting for deferredA.promise
     
     $scope.$apply(function() {
         $scope.useB = false;
     });
     
     // now we've changed, and we want $scope.extractedValue
     // to take deferredB.promise's value
     
     $scope.$apply(function() {
         deferredB.resolve(100);
     });
     
     // Awesome! Now $scope.extractedValue == 100
     
     $scope.$apply(function() {
         deferredA.resolve(0);
     });
     
     // Uh oh, now $scope.extractedValue == 0
     // unless we've invalidated the old callback
   #+END_SRC


**** Default configuration

By default, =$computed= will extract a value from a =$q= promise if
one is returned from the computed function.

#+BEGIN_SRC js
  $scope.$computed('extracted', function() {
      var deferred = $q.defer();
      deferred.resolve('a value'); // could happen later
      return deferred.promise;
  });
#+END_SRC

To serve as an example for custom extractors, this is how one would
specify the default extractor:

#+BEGIN_SRC js
  angular.module('app', ['ngComputed', 'ng'])
      .config(['$computedProvider', function($computedProvider) {
          $computedProvider.provideExtractor(['$q', function($q) {
              return function(value, callback) {
                  $q.when(value).then(callback, callback);
              };
          }]);
      }]);
#+END_SRC

This does not need to be done, however, as ~ng-computed~ will use
this extractor if no other extractor is specified.


**** Custom configuration

One possible form of an extractor will attempt to extract values from
"thunks". A thunk can be modelled as a function with zero arguments,
which must be invoked to retrieve the value it contains.

An extractor which dereferences thunks for =$computed= properties can
be easily implemented:

#+BEGIN_SRC js
  angular.module('app', ['ngComputed', 'ng'])
      .config(['$computedProvider', function($computedProvider) {
          $computedProvider.provideExtractor([function() {
              return function(value, callback) {
                  // because these are each called synchronously,
                  // they are already in a $digest cycle
                  if (angular.isFunction(value)) {
                      callback(value());
                  } else {
                      callback(value);
                  }
              };
          }]);
      }]);
#+END_SRC

If our application is configured with this extractor then the
following =$computed= property will be set to the value =10=.

#+BEGIN_SRC js
  $scope.$computed('value', function() {
      return function(){return 10;};
  });
#+END_SRC


*** Transformations


** Internals


** Comparison to pure AngularJS
