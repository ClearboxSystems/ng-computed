/*! ng-computed 0.0.2 16-04-2014 */!function(){"use strict";angular.module("ngComputed",["ng"]),angular.module("ngComputed").factory("$batchedWatch",["$rootScope",function(a){var b=a.$watch,c=function(a){setTimeout(function(){throw a},0)},d=1,e=function(a,e,f,g){var h=a[f],i=h[e];if(i){var j=i.lastArgs;if(j&&!j.registering){j.registering=!0;try{g.apply(j.self,j.args)}catch(k){c(k)}delete j.registering}}else i={fns:{}},i.deregister=b.call(this,e,function(){var a=this,b=arguments;angular.forEach(i.fns,function(d){try{d.apply(a,b)}catch(e){c(e)}}),i.lastArgs={self:a,args:b}},f),h[e]=i;var l=d++;return a[f][e].fns[l]=g,l},f=function(a){for(var b in a)return!1;return!0},g=function(a,b,c,d){var e=a[c];if(e[b]){var g=e[b],h=g.fns;delete h[d],f(h)&&(g.deregister(),delete a[c][b])}},h=function(a,c,d){var f=this;if(d=!!d,angular.isFunction(a))return b.call(this,a,c,d);var h;h=this.hasOwnProperty("$$batchedWatchers")?this.$$batchedWatchers:{"true":{},"false":{}};var i=e.call(f,h,a,d,c),j=function(){g.call(f,h,a,d,i)};return this.$$batchedWatchers=h,j};return h}]),angular.module("ngComputed").provider("$computed",[function(){var a=["$q",function(a){return function(b,c){a.when(b).then(c,c)}}];this.provideExtractor=function(b){a=b},this.$get=["$injector","$parse","$trackedEval","$exceptionHandler",function(b,c,d,e){var f=b.invoke(a),g=function(a,b,c){var d={};return angular.forEach(a,function(a,c){c in b?d[c]=a:a.deregister()}),angular.forEach(b,function(b,e){if(e in a);else{var f=function(){c()};switch(d[e]=b,b.type){case"equal":case"reference":b.deregister=b.scope.$watch(b.expr,f,"equal"==b.type);break;case"collection":b.deregister=b.scope.$watchCollection(b.expr,f);break;default:console.error("Unknown watch type: ",b.type," Not tracking dependency on: ",b.expr)}}}),d},h=function(a,b,c,h){var i=c,j={},k=function(){var c=d.trackDependencies.call(a,b,i);void 0===c.thrown?f(c.value,h):(f(void 0,h),e(c.thrown)),j=g(j,c.dependencies,k)};k();var l=function(){angular.isFunction(b.destroy)&&b.destroy(),g(j,{},null)};return l.setArgs=function(a){angular.equals(i,a)||(i=angular.copy(a),k())},l},i=function(a,b,c,d,e){if(b.length-d==1)return h(a,b[d],e,function(a){c(a)});var f=null,g=h(a,b[d],e,function(e){null===f?f=i(a,b,c,d+1,[e]):f.setArgs([e])}),j=function(){f&&f(),g()};return j.setArgs=function(a){g.setArgs(a)},j},j=function(a,b){var d=this,e=c(a).assign,f=angular.isArray(b)?b:[b];return i(d,f,function(a){e(d,a)},0,[])};return j}]}])}(window,document),angular.module("ngComputed").provider("$trackedEval",[function(){var a="equal";this.setDefaultWatchType=function(b){if("equal"!=b&&"reference"!=b&&"collection"!=b)throw new Error("Cannot default to watch of type '"+b+"': unknown type");a=b},this.$get=["$parse",function(b){var c=null,d=function(a,b){var d=c;c={};try{return{value:a.apply(this,b),dependencies:c}}catch(e){return{thrown:e,dependencies:c}}finally{c=d}},e=function(a,d,e){if(c){if(angular.isFunction(a))throw new Error("Function used in $trackedEval while tracking dependencies. Instead, call the function and use $trackedEval internally.");c[this.$id+"|"+a+"|"+d]={scope:this,expr:a,type:d}}return b(a)(this,e)},f=function(a,b){return e.call(this,a,"equal",b)},g=function(a,b){return e.call(this,a,"reference",b)},h=function(a,b){return e.call(this,a,"collection",b)},i=function(a){a.$evalEqual=f,a.$evalReference=g,a.$evalCollection=h,a.trackDependencies=d,Object.defineProperty(a,"trackDependencies",{enumerable:!1})};if(i(f),i(g),i(h),"equal"==a)return f;if("reference"==a)return g;if("collection"==a)return h;throw new Error("Cannot create watch of default type '"+a+"': unknown type")}]}]);