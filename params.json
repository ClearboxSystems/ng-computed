{"name":"ng-computed","tagline":"Computed properties for angularjs","body":"# ng-computed - 0.0.2\r\n\r\nComputed properties for [AngularJS][1], Ã  la [Knockout JS][2].\r\n\r\n[1]: http://angularjs.org/\r\n[2]: http://knockoutjs.com/\r\n\r\n## Summary\r\n\r\n`ng-computed` lets you write computed properties without worrying\r\nabout which values to register a `$watch` on and when.\r\n\r\n```javascript\r\n$scope.string = \"hello\";\r\n$scope.$computed('computedValue', function() {\r\n    return $scope.$eval('string') + \" world!\";\r\n});\r\n```\r\n\r\nIn this case, `$scope.computedValue` will take on the value `\"hello\r\nworld!\"`, while also reacting to changes to `$scope.string`.\r\n\r\n## Example\r\n\r\nAs an example, this is a simple translation of the KnockoutJS [computed\r\nobservable example][3]:\r\n\r\n```javascript\r\nangular.module(\"example\", [\"ngComputed\", \"ng\"])\r\n    .controller(\"ExampleController\", function($scope, $computed, $trackedEval) {\r\n        $scope.$computed = $computed;\r\n        $scope.$eval = $trackedEval;\r\n    \r\n        $scope.firstName = \"George\";\r\n        $scope.surname = \"Clooney\";\r\n        $scope.$computed(\"fullName\", function() {\r\n            return $scope.$eval(\"firstName\") + \" \" + $scope.$eval(\"surname\");\r\n        });\r\n    });\r\n```\r\n\r\n```html\r\n<html ng-app=\"example\">\r\n    ...\r\n    <div ng-controller=\"ExampleController\">\r\n        <div>\r\n            <input ng-model=\"firstName\">\r\n            <input ng-model=\"surname\">\r\n        </div>\r\n        <div>Hello, {{fullName}}</div>\r\n    </div>\r\n    ...\r\n</html>\r\n```\r\n\r\n[See this example on plunker][4]\r\n\r\n\r\nTo do this in plain AngularJS would require us to manage our watches\r\nexplicitly:\r\n\r\n```javascript\r\nangular.module(\"example\", [\"ng\"])\r\n    .controller(\"ExampleController\", function($scope) {\r\n        $scope.firstName = \"George\"; \r\n        $scope.surname = \"Clooney\";\r\n\r\n        $scope.$watch(\"firstName\", function(firstName) {\r\n            $scope.fullName = firstName + \" \" + $scope.surname;\r\n        });\r\n        $scope.$watch(\"surname\", function(surname) {\r\n            $scope.fullName = $scope.firstName + \" \" + surname;\r\n        });\r\n    });\r\n```\r\n\r\n`ng-computed` will do the work of managing watches for you. See\r\n[this example][5] to see it in action.\r\n\r\n[3]: http://knockoutjs.com/documentation/computedObservables.html\r\n[4]: http://plnkr.co/edit/dtK8nqK72fBiGYNNE5x8?p=preview\r\n[5]: http://plnkr.co/edit/12Z9ppZCpHcfpigXulPy?p=preview\r\n\r\n## Setup\r\n\r\nAt the top level we can add our functions to the root scope, even\r\ngoing so far as to replace the functions there:\r\n\r\n```javascript\r\nangular.module('app', ['ngComputed', 'ng'])\r\n    .run(['$rootScope', '$trackedEval', '$computed', function($rootScope, $trackedEval, $computed) {\r\n        // we have to use the prototype, otherwise isolate scopes miss out\r\n        angular.extend($rootScope.constructor.prototype, {\r\n            $eval: $trackedEval,\r\n            $computed: $computed\r\n        });\r\n    }]);\r\n```\r\n\r\nFor the majority of the documentation we will assume this setup,\r\nalthough you can also bind to different names on the scope prototype,\r\nor bind them on any sub-scope.\r\n\r\n## Basic use\r\n\r\nFor an average use case there shouldn't be much need to think\r\nparticularly hard about how you write computed properties. Just write\r\na function to calculate the value from other values on the scope,\r\nusing `$eval` to read from the scope instead of doing so yourself.\r\n\r\nAs a relatively meaningless example:\r\n\r\n```javascript\r\n$scope.$computed('computedValue', function() {\r\n    switch ($scope.$eval('operation')) {\r\n    case 'addition':\r\n        return $scope.$eval('add1') + $scope.$eval('add2');\r\n    case 'subtraction':\r\n        return $scope.$eval('sub1') - $scope.$eval('sub2');\r\n    case 'multiplication':\r\n        return $scope.$eval('mul1') * $scope.$eval('mul2');\r\n    case 'division':\r\n        if ($scope.$eval('div2') == 0) {\r\n            return null;\r\n        } else {\r\n            return $scope.$eval('div1') / $scope.$eval('div2');\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nFrom this, `ng-computed` will work out all the details of what needs\r\nto be watched, and when. So, if `$scope.operation == \"division\"` and\r\n`$scope.div2 == 0` then you'll only have watches registered on\r\n`$scope.operation` and `$scope.div2` values, but if `$scope.div2 != 0`\r\nthen you'll have three watches: `$scope.operation`, `$scope.div1` and\r\n`$scope.div2`.\r\n\r\n## Watches\r\n\r\nBy default, `$trackedEval` tracks all dependencies as deep equality\r\nwatches. This can be quite inefficient, especially for dependencies on\r\nlarge objects, so `ng-computed` provides two tools to help:\r\n\r\n1. `$watch` batching\r\n\r\n    Shipped along with `ng-computed` is a service called\r\n    `$batchedWatch`. It's a drop-in replacement for `Scope.$watch`\r\n    which can be used as `$watch` on the root scope (or on any\r\n    sub-scope) and will batch together expression watches where\r\n    possible. This can mean that multiple deep watches on the same\r\n    large object will only incur one `angular.copy`/`angular.equals`\r\n    per change.\r\n\r\n2. `$eval{Reference,Equal,Collection}`\r\n\r\n    The `$trackedEval` service is not just a simple function, there\r\n    are in fact three variations of `$trackedEval` which each track\r\n    the dependency as one of the varieties of watch:\r\n\r\n    * `$evalReference`, as a reference watch\r\n    * `$evalEqual`, as a deep equality watch\r\n    * `$evalCollection`, as a collection watch\r\n\r\n    These can be placed on a scope and used as normal:\r\n\r\n    ```javascript\r\n    $scope.$evalReference = $trackedEval.$evalReference;\r\n    $scope.$computed('computedValue', function() {\r\n        return $scope.$evalReference('shallowWatchedValue');\r\n    });\r\n    ```\r\n\r\n    By default `$trackedEval` is the `$evalEquals` function, but it\r\n    can be configured using angular's configuration mechanism:\r\n\r\n    ```javascript\r\n    angular.module('app', ['ngComputed', 'ng'])\r\n        .config(['$trackedEvalProvider', function($trackedEvalProvider) {\r\n            $trackedEvalProvider.setDefaultWatchType('equal' /* or 'reference' or 'collection'*/);\r\n    }]);\r\n    ```\r\n\r\n## Extractors\r\n\r\nBy default, `$computed` will extract a value from a `$q` promise if\r\nit's returned from the computed function:\r\n\r\n```javascript\r\n$scope.$computed('extracted', function() {\r\n    var deferred = $q.defer();\r\n    deferred.resolve('a value'); // could happen later\r\n    return deferred.promise;\r\n});\r\n```\r\n\r\nThis behaviour of \"extracting\" a value from the result of a\r\n`$computed` function is open for customisation through angular's\r\nconfiguration mechanism. This is how the default extractor is\r\nimplemented:\r\n\r\n```javascript\r\nangular.module('app', ['ngComputed', 'ng'])\r\n    .config(['$computedProvider', function($computedProvider) {\r\n        $computedProvider.provideExtractor(['$q', function($q) {\r\n            return function(value, callback) {\r\n                $q.when(value).then(callback, callback);\r\n            };\r\n        }]);\r\n    }]);\r\n```\r\n\r\nIt's the extractor's responsibility to ensure that any changes are\r\n`$digest`ed after extraction. This can usually be achieved by calling\r\n`$rootScope.$apply()` after invoking `callback(value)` for async code.\r\n\r\n## Transformations\r\n\r\nThus far we have seen `$computed` called with a function in the second\r\nargument, but it is also valid to call it with an array of\r\nfunctions. Each of these functions will be called in sequence, with\r\neach being given the result returned by the previous function\r\n(post-extraction).\r\n\r\n```javascript\r\n$scope.$computed('transformedValue', [function() {\r\n    return $scope.$eval('baseValue');\r\n}, function(previous) {\r\n    return previous + $scope.$eval('valueA');\r\n}, function(previous) {\r\n    return previous + $scope.$eval('valueB');\r\n}]);\r\n```\r\n\r\nEach of these transformation functions may have a separate set of\r\ndependencies. If a function's dependencies change then that function\r\nwill be re-evaluated, which may trigger the evaluation of the\r\nfollowing functions if the return value has changed.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}